# أنماط النظام وبنية قاعدة البيانات

## بنية قاعدة بيانات Supabase

تعتمد بنية قاعدة البيانات في Supabase على مجموعة من الجداول المترابطة لإدارة المستخدمين، جهات الاتصال، القوائم، العناصر، والإشعارات.

1.  **جدول المستخدمين (`users`)**
    *   `id`: UUID (معرف فريد للمستخدم، يُربط بـ Supabase Auth).
    *   `username`: TEXT (اسم مستخدم فريد، يُستخدم لإضافة جهات الاتصال).
    *   `name`: TEXT (الاسم الحقيقي للمستخدم).
    *   `email`: TEXT (البريد الإلكتروني للمستخدم).
    *   `avatar_url`: TEXT (رابط اختياري لصورة المستخدم المخزنة في Supabase Storage).
    *   `push_token`: TEXT (رمز الجهاز الفريد المستخدم لإرسال الإشعارات الخارجية عبر FCM، يُحدث عند تسجيل الدخول).
    *   `created_at`: TIMESTAMPTZ (تاريخ إنشاء الحساب).

2.  **جدول جهات الاتصال (`contacts`)**
    *   `id`: BIGSERIAL (معرف فريد).
    *   `user_id`: UUID (معرف المستخدم الذي قام بإضافة جهة الاتصال، مرتبط بـ `users.id`).
    *   `contact_user_id`: UUID (معرف المستخدم الذي تمت إضافته كجهة اتصال، مرتبط بـ `users.id`).
    *   `added_at`: TIMESTAMPTZ (تاريخ الإضافة).
    *   *(ملاحظة: قد يكون استخدام `contact_username` كما في الوصف الأصلي أسهل في بعض السيناريوهات، لكن الربط بـ `user_id` أكثر قوة للحفاظ على التكامل المرجعي)*.

3.  **جدول القوائم (`lists`)**
    *   `id`: UUID (معرف فريد للقائمة).
    *   `creator_id`: UUID (معرف المستخدم الذي أنشأ القائمة، مرتبط بـ `users.id`).
    *   `recipient_id`: UUID (معرف المستخدم الذي استلم القائمة، مرتبط بـ `users.id`).
    *   `status`: TEXT (حالة القائمة، مثل: 'sent', 'viewed', 'archived').
    *   `created_at`: TIMESTAMPTZ (تاريخ الإنشاء).

4.  **جدول العناصر (`items`)**
    *   `id`: UUID (معرف فريد للعنصر).
    *   `list_id`: UUID (معرف القائمة التي ينتمي إليها العنصر، مرتبط بـ `lists.id`).
    *   `name`: TEXT (اسم المنتج).
    *   `purchased`: BOOLEAN (حالة الشراء، `false` افتراضيًا).
    *   `purchased_by`: UUID (اختياري، معرف المستخدم الذي قام بشطب العنصر).
    *   `created_at`: TIMESTAMPTZ (تاريخ إضافة العنصر).
    *   `updated_at`: TIMESTAMPTZ (تاريخ آخر تحديث للحالة).

5.  **جدول الإشعارات (`notifications`)**
    *   `id`: BIGSERIAL (معرف فريد).
    *   `user_id`: UUID (معرف المستخدم الذي سيتلقى الإشعار، مرتبط بـ `users.id`).
    *   `type`: TEXT (نوع الإشعار، مثل: 'new_list', 'item_purchased', 'new_message').
    *   `message`: TEXT (نص الإشعار).
    *   `list_id`: UUID (اختياري، معرف القائمة المرتبطة بالإشعار، مرتبط بـ `lists.id`).
    *   `item_id`: UUID (اختياري، معرف العنصر المرتبط بالإشعار، مرتبط بـ `items.id`).
    *   `sender_id`: UUID (اختياري، معرف المستخدم الذي تسبب في الإشعار، مرتبط بـ `users.id`).
    *   `is_read`: BOOLEAN (`false` افتراضيًا).
    *   `created_at`: TIMESTAMPTZ (تاريخ إنشاء الإشعار).

6.  **جدول الرسائل/الردود (`messages`)**
    *   `id`: UUID (معرف فريد للرسالة).
    *   `list_id`: UUID (معرف القائمة المرتبطة بالرسالة، مرتبط بـ `lists.id`).
    *   `sender_id`: UUID (معرف المستخدم الذي أرسل الرسالة، مرتبط بـ `users.id`).
    *   `text`: TEXT (نص الرسالة).
    *   `created_at`: TIMESTAMPTZ (تاريخ الإرسال).

## أنماط التفاعل الرئيسية

*   **التحديثات الفورية (Realtime):** يتم الاعتماد بشكل كبير على Supabase Realtime للاستماع إلى التغييرات في الجداول الحيوية (خاصة `items` و `notifications` و `messages`).
    *   عندما يقوم المستلم بشطب عنصر (`items.purchased = true`), يتم تحديث الجدول، مما ي déclenche (يثير) إشعارًا فوريًا للمرسل عبر الاشتراك في Realtime.
    *   عند إنشاء إشعار جديد في جدول `notifications`, يتم إرساله فورًا إلى المستخدم المعني عبر Realtime، مما يتيح تحديث واجهة المستخدم (مثل عرض علامة إشعار جديدة وتشغيل الصوت).
    *   عند إرسال رسالة جديدة (`messages`), يتم إعلام المستلم عبر Realtime.
*   **سياسات أمان مستوى الصف (RLS):** يتم استخدام RLS لضمان أن المستخدمين يمكنهم فقط الوصول إلى بياناتهم الخاصة (قوائمهم، إشعاراتهم، جهات اتصالهم) أو البيانات التي تمت مشاركتها معهم بشكل صريح.
*   **الإشعارات الخارجية (Push):** سيتم استخدام Supabase Functions (أو آلية مشابهة) التي يتم déclencher (إثارتها) عند إضافة سجل جديد إلى جدول `notifications` (أو `lists` عند الإرسال الأولي، أو `messages`). هذه الـ Function ستقوم باسترداد `push_token` للمستخدم المستلم من جدول `users` وإرسال الإشعار عبر Firebase Cloud Messaging (FCM).
*   **فصل الواجهة عن المنطق:** استخدام Hooks مخصصة في الواجهة الأمامية (مثل `useRealtime`, `useNotifications`) لتغليف منطق التعامل مع الاشتراكات الفورية وجلب البيانات، مما يحافظ على نظافة المكونات. 